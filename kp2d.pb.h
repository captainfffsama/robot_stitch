// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: kp2d.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_kp2d_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_kp2d_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3015000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3015002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_kp2d_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_kp2d_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[8]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_kp2d_2eproto;
::PROTOBUF_NAMESPACE_ID::Metadata descriptor_table_kp2d_2eproto_metadata_getter(int index);
namespace KP2D {
class AlignReply;
struct AlignReplyDefaultTypeInternal;
extern AlignReplyDefaultTypeInternal _AlignReply_default_instance_;
class GetEssentialMatrixReply;
struct GetEssentialMatrixReplyDefaultTypeInternal;
extern GetEssentialMatrixReplyDefaultTypeInternal _GetEssentialMatrixReply_default_instance_;
class GetKPPosDescScoreMapReply;
struct GetKPPosDescScoreMapReplyDefaultTypeInternal;
extern GetKPPosDescScoreMapReplyDefaultTypeInternal _GetKPPosDescScoreMapReply_default_instance_;
class GetKPPosDescScoreReply;
struct GetKPPosDescScoreReplyDefaultTypeInternal;
extern GetKPPosDescScoreReplyDefaultTypeInternal _GetKPPosDescScoreReply_default_instance_;
class Image;
struct ImageDefaultTypeInternal;
extern ImageDefaultTypeInternal _Image_default_instance_;
class ImagePair;
struct ImagePairDefaultTypeInternal;
extern ImagePairDefaultTypeInternal _ImagePair_default_instance_;
class ImgAndThr;
struct ImgAndThrDefaultTypeInternal;
extern ImgAndThrDefaultTypeInternal _ImgAndThr_default_instance_;
class Tensor;
struct TensorDefaultTypeInternal;
extern TensorDefaultTypeInternal _Tensor_default_instance_;
}  // namespace KP2D
PROTOBUF_NAMESPACE_OPEN
template<> ::KP2D::AlignReply* Arena::CreateMaybeMessage<::KP2D::AlignReply>(Arena*);
template<> ::KP2D::GetEssentialMatrixReply* Arena::CreateMaybeMessage<::KP2D::GetEssentialMatrixReply>(Arena*);
template<> ::KP2D::GetKPPosDescScoreMapReply* Arena::CreateMaybeMessage<::KP2D::GetKPPosDescScoreMapReply>(Arena*);
template<> ::KP2D::GetKPPosDescScoreReply* Arena::CreateMaybeMessage<::KP2D::GetKPPosDescScoreReply>(Arena*);
template<> ::KP2D::Image* Arena::CreateMaybeMessage<::KP2D::Image>(Arena*);
template<> ::KP2D::ImagePair* Arena::CreateMaybeMessage<::KP2D::ImagePair>(Arena*);
template<> ::KP2D::ImgAndThr* Arena::CreateMaybeMessage<::KP2D::ImgAndThr>(Arena*);
template<> ::KP2D::Tensor* Arena::CreateMaybeMessage<::KP2D::Tensor>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace KP2D {

// ===================================================================

class Image PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:KP2D.Image) */ {
 public:
  inline Image() : Image(nullptr) {}
  virtual ~Image();
  explicit constexpr Image(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Image(const Image& from);
  Image(Image&& from) noexcept
    : Image() {
    *this = ::std::move(from);
  }

  inline Image& operator=(const Image& from) {
    CopyFrom(from);
    return *this;
  }
  inline Image& operator=(Image&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Image& default_instance() {
    return *internal_default_instance();
  }
  static inline const Image* internal_default_instance() {
    return reinterpret_cast<const Image*>(
               &_Image_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Image& a, Image& b) {
    a.Swap(&b);
  }
  inline void Swap(Image* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Image* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Image* New() const final {
    return CreateMaybeMessage<Image>(nullptr);
  }

  Image* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Image>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Image& from);
  void MergeFrom(const Image& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Image* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "KP2D.Image";
  }
  protected:
  explicit Image(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_kp2d_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImageFieldNumber = 1,
    kPathFieldNumber = 2,
  };
  // bytes image = 1;
  bool has_image() const;
  private:
  bool _internal_has_image() const;
  public:
  void clear_image();
  const std::string& image() const;
  void set_image(const std::string& value);
  void set_image(std::string&& value);
  void set_image(const char* value);
  void set_image(const void* value, size_t size);
  std::string* mutable_image();
  std::string* release_image();
  void set_allocated_image(std::string* image);
  private:
  const std::string& _internal_image() const;
  void _internal_set_image(const std::string& value);
  std::string* _internal_mutable_image();
  public:

  // string path = 2;
  bool has_path() const;
  private:
  bool _internal_has_path() const;
  public:
  void clear_path();
  const std::string& path() const;
  void set_path(const std::string& value);
  void set_path(std::string&& value);
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  std::string* mutable_path();
  std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // @@protoc_insertion_point(class_scope:KP2D.Image)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  friend struct ::TableStruct_kp2d_2eproto;
};
// -------------------------------------------------------------------

class ImgAndThr PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:KP2D.ImgAndThr) */ {
 public:
  inline ImgAndThr() : ImgAndThr(nullptr) {}
  virtual ~ImgAndThr();
  explicit constexpr ImgAndThr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImgAndThr(const ImgAndThr& from);
  ImgAndThr(ImgAndThr&& from) noexcept
    : ImgAndThr() {
    *this = ::std::move(from);
  }

  inline ImgAndThr& operator=(const ImgAndThr& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImgAndThr& operator=(ImgAndThr&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ImgAndThr& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImgAndThr* internal_default_instance() {
    return reinterpret_cast<const ImgAndThr*>(
               &_ImgAndThr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ImgAndThr& a, ImgAndThr& b) {
    a.Swap(&b);
  }
  inline void Swap(ImgAndThr* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImgAndThr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ImgAndThr* New() const final {
    return CreateMaybeMessage<ImgAndThr>(nullptr);
  }

  ImgAndThr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ImgAndThr>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ImgAndThr& from);
  void MergeFrom(const ImgAndThr& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImgAndThr* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "KP2D.ImgAndThr";
  }
  protected:
  explicit ImgAndThr(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_kp2d_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImgFieldNumber = 1,
    kThresholdFieldNumber = 2,
  };
  // .KP2D.Image img = 1;
  bool has_img() const;
  private:
  bool _internal_has_img() const;
  public:
  void clear_img();
  const ::KP2D::Image& img() const;
  ::KP2D::Image* release_img();
  ::KP2D::Image* mutable_img();
  void set_allocated_img(::KP2D::Image* img);
  private:
  const ::KP2D::Image& _internal_img() const;
  ::KP2D::Image* _internal_mutable_img();
  public:
  void unsafe_arena_set_allocated_img(
      ::KP2D::Image* img);
  ::KP2D::Image* unsafe_arena_release_img();

  // float threshold = 2;
  bool has_threshold() const;
  private:
  bool _internal_has_threshold() const;
  public:
  void clear_threshold();
  float threshold() const;
  void set_threshold(float value);
  private:
  float _internal_threshold() const;
  void _internal_set_threshold(float value);
  public:

  // @@protoc_insertion_point(class_scope:KP2D.ImgAndThr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::KP2D::Image* img_;
  float threshold_;
  friend struct ::TableStruct_kp2d_2eproto;
};
// -------------------------------------------------------------------

class ImagePair PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:KP2D.ImagePair) */ {
 public:
  inline ImagePair() : ImagePair(nullptr) {}
  virtual ~ImagePair();
  explicit constexpr ImagePair(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImagePair(const ImagePair& from);
  ImagePair(ImagePair&& from) noexcept
    : ImagePair() {
    *this = ::std::move(from);
  }

  inline ImagePair& operator=(const ImagePair& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImagePair& operator=(ImagePair&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ImagePair& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImagePair* internal_default_instance() {
    return reinterpret_cast<const ImagePair*>(
               &_ImagePair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ImagePair& a, ImagePair& b) {
    a.Swap(&b);
  }
  inline void Swap(ImagePair* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImagePair* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ImagePair* New() const final {
    return CreateMaybeMessage<ImagePair>(nullptr);
  }

  ImagePair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ImagePair>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ImagePair& from);
  void MergeFrom(const ImagePair& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImagePair* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "KP2D.ImagePair";
  }
  protected:
  explicit ImagePair(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_kp2d_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImageAFieldNumber = 1,
    kImageBFieldNumber = 2,
  };
  // .KP2D.Image imageA = 1;
  bool has_imagea() const;
  private:
  bool _internal_has_imagea() const;
  public:
  void clear_imagea();
  const ::KP2D::Image& imagea() const;
  ::KP2D::Image* release_imagea();
  ::KP2D::Image* mutable_imagea();
  void set_allocated_imagea(::KP2D::Image* imagea);
  private:
  const ::KP2D::Image& _internal_imagea() const;
  ::KP2D::Image* _internal_mutable_imagea();
  public:
  void unsafe_arena_set_allocated_imagea(
      ::KP2D::Image* imagea);
  ::KP2D::Image* unsafe_arena_release_imagea();

  // .KP2D.Image imageB = 2;
  bool has_imageb() const;
  private:
  bool _internal_has_imageb() const;
  public:
  void clear_imageb();
  const ::KP2D::Image& imageb() const;
  ::KP2D::Image* release_imageb();
  ::KP2D::Image* mutable_imageb();
  void set_allocated_imageb(::KP2D::Image* imageb);
  private:
  const ::KP2D::Image& _internal_imageb() const;
  ::KP2D::Image* _internal_mutable_imageb();
  public:
  void unsafe_arena_set_allocated_imageb(
      ::KP2D::Image* imageb);
  ::KP2D::Image* unsafe_arena_release_imageb();

  // @@protoc_insertion_point(class_scope:KP2D.ImagePair)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::KP2D::Image* imagea_;
  ::KP2D::Image* imageb_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kp2d_2eproto;
};
// -------------------------------------------------------------------

class Tensor PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:KP2D.Tensor) */ {
 public:
  inline Tensor() : Tensor(nullptr) {}
  virtual ~Tensor();
  explicit constexpr Tensor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Tensor(const Tensor& from);
  Tensor(Tensor&& from) noexcept
    : Tensor() {
    *this = ::std::move(from);
  }

  inline Tensor& operator=(const Tensor& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tensor& operator=(Tensor&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Tensor& default_instance() {
    return *internal_default_instance();
  }
  static inline const Tensor* internal_default_instance() {
    return reinterpret_cast<const Tensor*>(
               &_Tensor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Tensor& a, Tensor& b) {
    a.Swap(&b);
  }
  inline void Swap(Tensor* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tensor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Tensor* New() const final {
    return CreateMaybeMessage<Tensor>(nullptr);
  }

  Tensor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Tensor>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Tensor& from);
  void MergeFrom(const Tensor& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tensor* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "KP2D.Tensor";
  }
  protected:
  explicit Tensor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_kp2d_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kShapeFieldNumber = 2,
  };
  // repeated float data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  private:
  float _internal_data(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_data() const;
  void _internal_add_data(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_data();
  public:
  float data(int index) const;
  void set_data(int index, float value);
  void add_data(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_data();

  // repeated int32 shape = 2;
  int shape_size() const;
  private:
  int _internal_shape_size() const;
  public:
  void clear_shape();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_shape(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_shape() const;
  void _internal_add_shape(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_shape();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 shape(int index) const;
  void set_shape(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_shape(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      shape() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_shape();

  // @@protoc_insertion_point(class_scope:KP2D.Tensor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > data_;
  mutable std::atomic<int> _data_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > shape_;
  mutable std::atomic<int> _shape_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kp2d_2eproto;
};
// -------------------------------------------------------------------

class AlignReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:KP2D.AlignReply) */ {
 public:
  inline AlignReply() : AlignReply(nullptr) {}
  virtual ~AlignReply();
  explicit constexpr AlignReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AlignReply(const AlignReply& from);
  AlignReply(AlignReply&& from) noexcept
    : AlignReply() {
    *this = ::std::move(from);
  }

  inline AlignReply& operator=(const AlignReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline AlignReply& operator=(AlignReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AlignReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const AlignReply* internal_default_instance() {
    return reinterpret_cast<const AlignReply*>(
               &_AlignReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(AlignReply& a, AlignReply& b) {
    a.Swap(&b);
  }
  inline void Swap(AlignReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AlignReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AlignReply* New() const final {
    return CreateMaybeMessage<AlignReply>(nullptr);
  }

  AlignReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AlignReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AlignReply& from);
  void MergeFrom(const AlignReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AlignReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "KP2D.AlignReply";
  }
  protected:
  explicit AlignReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_kp2d_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImgARoiFieldNumber = 3,
    kImgBRoiFieldNumber = 4,
    kImgASameFieldNumber = 1,
    kImgBSameFieldNumber = 2,
    kStatusFieldNumber = 5,
  };
  // repeated int32 imgA_roi = 3;
  int imga_roi_size() const;
  private:
  int _internal_imga_roi_size() const;
  public:
  void clear_imga_roi();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_imga_roi(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_imga_roi() const;
  void _internal_add_imga_roi(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_imga_roi();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 imga_roi(int index) const;
  void set_imga_roi(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_imga_roi(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      imga_roi() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_imga_roi();

  // repeated int32 imgB_roi = 4;
  int imgb_roi_size() const;
  private:
  int _internal_imgb_roi_size() const;
  public:
  void clear_imgb_roi();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_imgb_roi(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_imgb_roi() const;
  void _internal_add_imgb_roi(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_imgb_roi();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 imgb_roi(int index) const;
  void set_imgb_roi(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_imgb_roi(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      imgb_roi() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_imgb_roi();

  // .KP2D.Image imgA_same = 1;
  bool has_imga_same() const;
  private:
  bool _internal_has_imga_same() const;
  public:
  void clear_imga_same();
  const ::KP2D::Image& imga_same() const;
  ::KP2D::Image* release_imga_same();
  ::KP2D::Image* mutable_imga_same();
  void set_allocated_imga_same(::KP2D::Image* imga_same);
  private:
  const ::KP2D::Image& _internal_imga_same() const;
  ::KP2D::Image* _internal_mutable_imga_same();
  public:
  void unsafe_arena_set_allocated_imga_same(
      ::KP2D::Image* imga_same);
  ::KP2D::Image* unsafe_arena_release_imga_same();

  // .KP2D.Image imgB_same = 2;
  bool has_imgb_same() const;
  private:
  bool _internal_has_imgb_same() const;
  public:
  void clear_imgb_same();
  const ::KP2D::Image& imgb_same() const;
  ::KP2D::Image* release_imgb_same();
  ::KP2D::Image* mutable_imgb_same();
  void set_allocated_imgb_same(::KP2D::Image* imgb_same);
  private:
  const ::KP2D::Image& _internal_imgb_same() const;
  ::KP2D::Image* _internal_mutable_imgb_same();
  public:
  void unsafe_arena_set_allocated_imgb_same(
      ::KP2D::Image* imgb_same);
  ::KP2D::Image* unsafe_arena_release_imgb_same();

  // int32 status = 5;
  void clear_status();
  ::PROTOBUF_NAMESPACE_ID::int32 status() const;
  void set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_status() const;
  void _internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:KP2D.AlignReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > imga_roi_;
  mutable std::atomic<int> _imga_roi_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > imgb_roi_;
  mutable std::atomic<int> _imgb_roi_cached_byte_size_;
  ::KP2D::Image* imga_same_;
  ::KP2D::Image* imgb_same_;
  ::PROTOBUF_NAMESPACE_ID::int32 status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kp2d_2eproto;
};
// -------------------------------------------------------------------

class GetEssentialMatrixReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:KP2D.GetEssentialMatrixReply) */ {
 public:
  inline GetEssentialMatrixReply() : GetEssentialMatrixReply(nullptr) {}
  virtual ~GetEssentialMatrixReply();
  explicit constexpr GetEssentialMatrixReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetEssentialMatrixReply(const GetEssentialMatrixReply& from);
  GetEssentialMatrixReply(GetEssentialMatrixReply&& from) noexcept
    : GetEssentialMatrixReply() {
    *this = ::std::move(from);
  }

  inline GetEssentialMatrixReply& operator=(const GetEssentialMatrixReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetEssentialMatrixReply& operator=(GetEssentialMatrixReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetEssentialMatrixReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetEssentialMatrixReply* internal_default_instance() {
    return reinterpret_cast<const GetEssentialMatrixReply*>(
               &_GetEssentialMatrixReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GetEssentialMatrixReply& a, GetEssentialMatrixReply& b) {
    a.Swap(&b);
  }
  inline void Swap(GetEssentialMatrixReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetEssentialMatrixReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetEssentialMatrixReply* New() const final {
    return CreateMaybeMessage<GetEssentialMatrixReply>(nullptr);
  }

  GetEssentialMatrixReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetEssentialMatrixReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetEssentialMatrixReply& from);
  void MergeFrom(const GetEssentialMatrixReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetEssentialMatrixReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "KP2D.GetEssentialMatrixReply";
  }
  protected:
  explicit GetEssentialMatrixReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_kp2d_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMatrixFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // .KP2D.Tensor matrix = 1;
  bool has_matrix() const;
  private:
  bool _internal_has_matrix() const;
  public:
  void clear_matrix();
  const ::KP2D::Tensor& matrix() const;
  ::KP2D::Tensor* release_matrix();
  ::KP2D::Tensor* mutable_matrix();
  void set_allocated_matrix(::KP2D::Tensor* matrix);
  private:
  const ::KP2D::Tensor& _internal_matrix() const;
  ::KP2D::Tensor* _internal_mutable_matrix();
  public:
  void unsafe_arena_set_allocated_matrix(
      ::KP2D::Tensor* matrix);
  ::KP2D::Tensor* unsafe_arena_release_matrix();

  // int32 status = 2;
  void clear_status();
  ::PROTOBUF_NAMESPACE_ID::int32 status() const;
  void set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_status() const;
  void _internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:KP2D.GetEssentialMatrixReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::KP2D::Tensor* matrix_;
  ::PROTOBUF_NAMESPACE_ID::int32 status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kp2d_2eproto;
};
// -------------------------------------------------------------------

class GetKPPosDescScoreReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:KP2D.GetKPPosDescScoreReply) */ {
 public:
  inline GetKPPosDescScoreReply() : GetKPPosDescScoreReply(nullptr) {}
  virtual ~GetKPPosDescScoreReply();
  explicit constexpr GetKPPosDescScoreReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetKPPosDescScoreReply(const GetKPPosDescScoreReply& from);
  GetKPPosDescScoreReply(GetKPPosDescScoreReply&& from) noexcept
    : GetKPPosDescScoreReply() {
    *this = ::std::move(from);
  }

  inline GetKPPosDescScoreReply& operator=(const GetKPPosDescScoreReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetKPPosDescScoreReply& operator=(GetKPPosDescScoreReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetKPPosDescScoreReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetKPPosDescScoreReply* internal_default_instance() {
    return reinterpret_cast<const GetKPPosDescScoreReply*>(
               &_GetKPPosDescScoreReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetKPPosDescScoreReply& a, GetKPPosDescScoreReply& b) {
    a.Swap(&b);
  }
  inline void Swap(GetKPPosDescScoreReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetKPPosDescScoreReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetKPPosDescScoreReply* New() const final {
    return CreateMaybeMessage<GetKPPosDescScoreReply>(nullptr);
  }

  GetKPPosDescScoreReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetKPPosDescScoreReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetKPPosDescScoreReply& from);
  void MergeFrom(const GetKPPosDescScoreReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetKPPosDescScoreReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "KP2D.GetKPPosDescScoreReply";
  }
  protected:
  explicit GetKPPosDescScoreReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_kp2d_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKpFieldNumber = 1,
    kDescFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // .KP2D.Tensor kp = 1;
  bool has_kp() const;
  private:
  bool _internal_has_kp() const;
  public:
  void clear_kp();
  const ::KP2D::Tensor& kp() const;
  ::KP2D::Tensor* release_kp();
  ::KP2D::Tensor* mutable_kp();
  void set_allocated_kp(::KP2D::Tensor* kp);
  private:
  const ::KP2D::Tensor& _internal_kp() const;
  ::KP2D::Tensor* _internal_mutable_kp();
  public:
  void unsafe_arena_set_allocated_kp(
      ::KP2D::Tensor* kp);
  ::KP2D::Tensor* unsafe_arena_release_kp();

  // .KP2D.Tensor desc = 2;
  bool has_desc() const;
  private:
  bool _internal_has_desc() const;
  public:
  void clear_desc();
  const ::KP2D::Tensor& desc() const;
  ::KP2D::Tensor* release_desc();
  ::KP2D::Tensor* mutable_desc();
  void set_allocated_desc(::KP2D::Tensor* desc);
  private:
  const ::KP2D::Tensor& _internal_desc() const;
  ::KP2D::Tensor* _internal_mutable_desc();
  public:
  void unsafe_arena_set_allocated_desc(
      ::KP2D::Tensor* desc);
  ::KP2D::Tensor* unsafe_arena_release_desc();

  // int32 status = 3;
  void clear_status();
  ::PROTOBUF_NAMESPACE_ID::int32 status() const;
  void set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_status() const;
  void _internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:KP2D.GetKPPosDescScoreReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::KP2D::Tensor* kp_;
  ::KP2D::Tensor* desc_;
  ::PROTOBUF_NAMESPACE_ID::int32 status_;
  friend struct ::TableStruct_kp2d_2eproto;
};
// -------------------------------------------------------------------

class GetKPPosDescScoreMapReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:KP2D.GetKPPosDescScoreMapReply) */ {
 public:
  inline GetKPPosDescScoreMapReply() : GetKPPosDescScoreMapReply(nullptr) {}
  virtual ~GetKPPosDescScoreMapReply();
  explicit constexpr GetKPPosDescScoreMapReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetKPPosDescScoreMapReply(const GetKPPosDescScoreMapReply& from);
  GetKPPosDescScoreMapReply(GetKPPosDescScoreMapReply&& from) noexcept
    : GetKPPosDescScoreMapReply() {
    *this = ::std::move(from);
  }

  inline GetKPPosDescScoreMapReply& operator=(const GetKPPosDescScoreMapReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetKPPosDescScoreMapReply& operator=(GetKPPosDescScoreMapReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetKPPosDescScoreMapReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetKPPosDescScoreMapReply* internal_default_instance() {
    return reinterpret_cast<const GetKPPosDescScoreMapReply*>(
               &_GetKPPosDescScoreMapReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetKPPosDescScoreMapReply& a, GetKPPosDescScoreMapReply& b) {
    a.Swap(&b);
  }
  inline void Swap(GetKPPosDescScoreMapReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetKPPosDescScoreMapReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetKPPosDescScoreMapReply* New() const final {
    return CreateMaybeMessage<GetKPPosDescScoreMapReply>(nullptr);
  }

  GetKPPosDescScoreMapReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetKPPosDescScoreMapReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetKPPosDescScoreMapReply& from);
  void MergeFrom(const GetKPPosDescScoreMapReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetKPPosDescScoreMapReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "KP2D.GetKPPosDescScoreMapReply";
  }
  protected:
  explicit GetKPPosDescScoreMapReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_kp2d_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProbFieldNumber = 1,
    kDescFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // .KP2D.Tensor prob = 1;
  bool has_prob() const;
  private:
  bool _internal_has_prob() const;
  public:
  void clear_prob();
  const ::KP2D::Tensor& prob() const;
  ::KP2D::Tensor* release_prob();
  ::KP2D::Tensor* mutable_prob();
  void set_allocated_prob(::KP2D::Tensor* prob);
  private:
  const ::KP2D::Tensor& _internal_prob() const;
  ::KP2D::Tensor* _internal_mutable_prob();
  public:
  void unsafe_arena_set_allocated_prob(
      ::KP2D::Tensor* prob);
  ::KP2D::Tensor* unsafe_arena_release_prob();

  // .KP2D.Tensor desc = 2;
  bool has_desc() const;
  private:
  bool _internal_has_desc() const;
  public:
  void clear_desc();
  const ::KP2D::Tensor& desc() const;
  ::KP2D::Tensor* release_desc();
  ::KP2D::Tensor* mutable_desc();
  void set_allocated_desc(::KP2D::Tensor* desc);
  private:
  const ::KP2D::Tensor& _internal_desc() const;
  ::KP2D::Tensor* _internal_mutable_desc();
  public:
  void unsafe_arena_set_allocated_desc(
      ::KP2D::Tensor* desc);
  ::KP2D::Tensor* unsafe_arena_release_desc();

  // int32 status = 3;
  void clear_status();
  ::PROTOBUF_NAMESPACE_ID::int32 status() const;
  void set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_status() const;
  void _internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:KP2D.GetKPPosDescScoreMapReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::KP2D::Tensor* prob_;
  ::KP2D::Tensor* desc_;
  ::PROTOBUF_NAMESPACE_ID::int32 status_;
  friend struct ::TableStruct_kp2d_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Image

// bytes image = 1;
inline bool Image::_internal_has_image() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Image::has_image() const {
  return _internal_has_image();
}
inline void Image::clear_image() {
  image_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Image::image() const {
  // @@protoc_insertion_point(field_get:KP2D.Image.image)
  return _internal_image();
}
inline void Image::set_image(const std::string& value) {
  _internal_set_image(value);
  // @@protoc_insertion_point(field_set:KP2D.Image.image)
}
inline std::string* Image::mutable_image() {
  // @@protoc_insertion_point(field_mutable:KP2D.Image.image)
  return _internal_mutable_image();
}
inline const std::string& Image::_internal_image() const {
  return image_.Get();
}
inline void Image::_internal_set_image(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  image_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Image::set_image(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  image_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:KP2D.Image.image)
}
inline void Image::set_image(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  image_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:KP2D.Image.image)
}
inline void Image::set_image(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  image_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:KP2D.Image.image)
}
inline std::string* Image::_internal_mutable_image() {
  _has_bits_[0] |= 0x00000001u;
  return image_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Image::release_image() {
  // @@protoc_insertion_point(field_release:KP2D.Image.image)
  if (!_internal_has_image()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return image_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Image::set_allocated_image(std::string* image) {
  if (image != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  image_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), image,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:KP2D.Image.image)
}

// string path = 2;
inline bool Image::_internal_has_path() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Image::has_path() const {
  return _internal_has_path();
}
inline void Image::clear_path() {
  path_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Image::path() const {
  // @@protoc_insertion_point(field_get:KP2D.Image.path)
  return _internal_path();
}
inline void Image::set_path(const std::string& value) {
  _internal_set_path(value);
  // @@protoc_insertion_point(field_set:KP2D.Image.path)
}
inline std::string* Image::mutable_path() {
  // @@protoc_insertion_point(field_mutable:KP2D.Image.path)
  return _internal_mutable_path();
}
inline const std::string& Image::_internal_path() const {
  return path_.Get();
}
inline void Image::_internal_set_path(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Image::set_path(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  path_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:KP2D.Image.path)
}
inline void Image::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:KP2D.Image.path)
}
inline void Image::set_path(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:KP2D.Image.path)
}
inline std::string* Image::_internal_mutable_path() {
  _has_bits_[0] |= 0x00000002u;
  return path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Image::release_path() {
  // @@protoc_insertion_point(field_release:KP2D.Image.path)
  if (!_internal_has_path()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return path_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Image::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:KP2D.Image.path)
}

// -------------------------------------------------------------------

// ImgAndThr

// .KP2D.Image img = 1;
inline bool ImgAndThr::_internal_has_img() const {
  return this != internal_default_instance() && img_ != nullptr;
}
inline bool ImgAndThr::has_img() const {
  return _internal_has_img();
}
inline void ImgAndThr::clear_img() {
  if (GetArena() == nullptr && img_ != nullptr) {
    delete img_;
  }
  img_ = nullptr;
}
inline const ::KP2D::Image& ImgAndThr::_internal_img() const {
  const ::KP2D::Image* p = img_;
  return p != nullptr ? *p : reinterpret_cast<const ::KP2D::Image&>(
      ::KP2D::_Image_default_instance_);
}
inline const ::KP2D::Image& ImgAndThr::img() const {
  // @@protoc_insertion_point(field_get:KP2D.ImgAndThr.img)
  return _internal_img();
}
inline void ImgAndThr::unsafe_arena_set_allocated_img(
    ::KP2D::Image* img) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(img_);
  }
  img_ = img;
  if (img) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KP2D.ImgAndThr.img)
}
inline ::KP2D::Image* ImgAndThr::release_img() {
  
  ::KP2D::Image* temp = img_;
  img_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::KP2D::Image* ImgAndThr::unsafe_arena_release_img() {
  // @@protoc_insertion_point(field_release:KP2D.ImgAndThr.img)
  
  ::KP2D::Image* temp = img_;
  img_ = nullptr;
  return temp;
}
inline ::KP2D::Image* ImgAndThr::_internal_mutable_img() {
  
  if (img_ == nullptr) {
    auto* p = CreateMaybeMessage<::KP2D::Image>(GetArena());
    img_ = p;
  }
  return img_;
}
inline ::KP2D::Image* ImgAndThr::mutable_img() {
  // @@protoc_insertion_point(field_mutable:KP2D.ImgAndThr.img)
  return _internal_mutable_img();
}
inline void ImgAndThr::set_allocated_img(::KP2D::Image* img) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete img_;
  }
  if (img) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(img);
    if (message_arena != submessage_arena) {
      img = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, img, submessage_arena);
    }
    
  } else {
    
  }
  img_ = img;
  // @@protoc_insertion_point(field_set_allocated:KP2D.ImgAndThr.img)
}

// float threshold = 2;
inline bool ImgAndThr::_internal_has_threshold() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ImgAndThr::has_threshold() const {
  return _internal_has_threshold();
}
inline void ImgAndThr::clear_threshold() {
  threshold_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float ImgAndThr::_internal_threshold() const {
  return threshold_;
}
inline float ImgAndThr::threshold() const {
  // @@protoc_insertion_point(field_get:KP2D.ImgAndThr.threshold)
  return _internal_threshold();
}
inline void ImgAndThr::_internal_set_threshold(float value) {
  _has_bits_[0] |= 0x00000001u;
  threshold_ = value;
}
inline void ImgAndThr::set_threshold(float value) {
  _internal_set_threshold(value);
  // @@protoc_insertion_point(field_set:KP2D.ImgAndThr.threshold)
}

// -------------------------------------------------------------------

// ImagePair

// .KP2D.Image imageA = 1;
inline bool ImagePair::_internal_has_imagea() const {
  return this != internal_default_instance() && imagea_ != nullptr;
}
inline bool ImagePair::has_imagea() const {
  return _internal_has_imagea();
}
inline void ImagePair::clear_imagea() {
  if (GetArena() == nullptr && imagea_ != nullptr) {
    delete imagea_;
  }
  imagea_ = nullptr;
}
inline const ::KP2D::Image& ImagePair::_internal_imagea() const {
  const ::KP2D::Image* p = imagea_;
  return p != nullptr ? *p : reinterpret_cast<const ::KP2D::Image&>(
      ::KP2D::_Image_default_instance_);
}
inline const ::KP2D::Image& ImagePair::imagea() const {
  // @@protoc_insertion_point(field_get:KP2D.ImagePair.imageA)
  return _internal_imagea();
}
inline void ImagePair::unsafe_arena_set_allocated_imagea(
    ::KP2D::Image* imagea) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(imagea_);
  }
  imagea_ = imagea;
  if (imagea) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KP2D.ImagePair.imageA)
}
inline ::KP2D::Image* ImagePair::release_imagea() {
  
  ::KP2D::Image* temp = imagea_;
  imagea_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::KP2D::Image* ImagePair::unsafe_arena_release_imagea() {
  // @@protoc_insertion_point(field_release:KP2D.ImagePair.imageA)
  
  ::KP2D::Image* temp = imagea_;
  imagea_ = nullptr;
  return temp;
}
inline ::KP2D::Image* ImagePair::_internal_mutable_imagea() {
  
  if (imagea_ == nullptr) {
    auto* p = CreateMaybeMessage<::KP2D::Image>(GetArena());
    imagea_ = p;
  }
  return imagea_;
}
inline ::KP2D::Image* ImagePair::mutable_imagea() {
  // @@protoc_insertion_point(field_mutable:KP2D.ImagePair.imageA)
  return _internal_mutable_imagea();
}
inline void ImagePair::set_allocated_imagea(::KP2D::Image* imagea) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete imagea_;
  }
  if (imagea) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(imagea);
    if (message_arena != submessage_arena) {
      imagea = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, imagea, submessage_arena);
    }
    
  } else {
    
  }
  imagea_ = imagea;
  // @@protoc_insertion_point(field_set_allocated:KP2D.ImagePair.imageA)
}

// .KP2D.Image imageB = 2;
inline bool ImagePair::_internal_has_imageb() const {
  return this != internal_default_instance() && imageb_ != nullptr;
}
inline bool ImagePair::has_imageb() const {
  return _internal_has_imageb();
}
inline void ImagePair::clear_imageb() {
  if (GetArena() == nullptr && imageb_ != nullptr) {
    delete imageb_;
  }
  imageb_ = nullptr;
}
inline const ::KP2D::Image& ImagePair::_internal_imageb() const {
  const ::KP2D::Image* p = imageb_;
  return p != nullptr ? *p : reinterpret_cast<const ::KP2D::Image&>(
      ::KP2D::_Image_default_instance_);
}
inline const ::KP2D::Image& ImagePair::imageb() const {
  // @@protoc_insertion_point(field_get:KP2D.ImagePair.imageB)
  return _internal_imageb();
}
inline void ImagePair::unsafe_arena_set_allocated_imageb(
    ::KP2D::Image* imageb) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(imageb_);
  }
  imageb_ = imageb;
  if (imageb) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KP2D.ImagePair.imageB)
}
inline ::KP2D::Image* ImagePair::release_imageb() {
  
  ::KP2D::Image* temp = imageb_;
  imageb_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::KP2D::Image* ImagePair::unsafe_arena_release_imageb() {
  // @@protoc_insertion_point(field_release:KP2D.ImagePair.imageB)
  
  ::KP2D::Image* temp = imageb_;
  imageb_ = nullptr;
  return temp;
}
inline ::KP2D::Image* ImagePair::_internal_mutable_imageb() {
  
  if (imageb_ == nullptr) {
    auto* p = CreateMaybeMessage<::KP2D::Image>(GetArena());
    imageb_ = p;
  }
  return imageb_;
}
inline ::KP2D::Image* ImagePair::mutable_imageb() {
  // @@protoc_insertion_point(field_mutable:KP2D.ImagePair.imageB)
  return _internal_mutable_imageb();
}
inline void ImagePair::set_allocated_imageb(::KP2D::Image* imageb) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete imageb_;
  }
  if (imageb) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(imageb);
    if (message_arena != submessage_arena) {
      imageb = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, imageb, submessage_arena);
    }
    
  } else {
    
  }
  imageb_ = imageb;
  // @@protoc_insertion_point(field_set_allocated:KP2D.ImagePair.imageB)
}

// -------------------------------------------------------------------

// Tensor

// repeated float data = 1;
inline int Tensor::_internal_data_size() const {
  return data_.size();
}
inline int Tensor::data_size() const {
  return _internal_data_size();
}
inline void Tensor::clear_data() {
  data_.Clear();
}
inline float Tensor::_internal_data(int index) const {
  return data_.Get(index);
}
inline float Tensor::data(int index) const {
  // @@protoc_insertion_point(field_get:KP2D.Tensor.data)
  return _internal_data(index);
}
inline void Tensor::set_data(int index, float value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:KP2D.Tensor.data)
}
inline void Tensor::_internal_add_data(float value) {
  data_.Add(value);
}
inline void Tensor::add_data(float value) {
  _internal_add_data(value);
  // @@protoc_insertion_point(field_add:KP2D.Tensor.data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Tensor::_internal_data() const {
  return data_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Tensor::data() const {
  // @@protoc_insertion_point(field_list:KP2D.Tensor.data)
  return _internal_data();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Tensor::_internal_mutable_data() {
  return &data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Tensor::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:KP2D.Tensor.data)
  return _internal_mutable_data();
}

// repeated int32 shape = 2;
inline int Tensor::_internal_shape_size() const {
  return shape_.size();
}
inline int Tensor::shape_size() const {
  return _internal_shape_size();
}
inline void Tensor::clear_shape() {
  shape_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Tensor::_internal_shape(int index) const {
  return shape_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Tensor::shape(int index) const {
  // @@protoc_insertion_point(field_get:KP2D.Tensor.shape)
  return _internal_shape(index);
}
inline void Tensor::set_shape(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  shape_.Set(index, value);
  // @@protoc_insertion_point(field_set:KP2D.Tensor.shape)
}
inline void Tensor::_internal_add_shape(::PROTOBUF_NAMESPACE_ID::int32 value) {
  shape_.Add(value);
}
inline void Tensor::add_shape(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_shape(value);
  // @@protoc_insertion_point(field_add:KP2D.Tensor.shape)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
Tensor::_internal_shape() const {
  return shape_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
Tensor::shape() const {
  // @@protoc_insertion_point(field_list:KP2D.Tensor.shape)
  return _internal_shape();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
Tensor::_internal_mutable_shape() {
  return &shape_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
Tensor::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:KP2D.Tensor.shape)
  return _internal_mutable_shape();
}

// -------------------------------------------------------------------

// AlignReply

// .KP2D.Image imgA_same = 1;
inline bool AlignReply::_internal_has_imga_same() const {
  return this != internal_default_instance() && imga_same_ != nullptr;
}
inline bool AlignReply::has_imga_same() const {
  return _internal_has_imga_same();
}
inline void AlignReply::clear_imga_same() {
  if (GetArena() == nullptr && imga_same_ != nullptr) {
    delete imga_same_;
  }
  imga_same_ = nullptr;
}
inline const ::KP2D::Image& AlignReply::_internal_imga_same() const {
  const ::KP2D::Image* p = imga_same_;
  return p != nullptr ? *p : reinterpret_cast<const ::KP2D::Image&>(
      ::KP2D::_Image_default_instance_);
}
inline const ::KP2D::Image& AlignReply::imga_same() const {
  // @@protoc_insertion_point(field_get:KP2D.AlignReply.imgA_same)
  return _internal_imga_same();
}
inline void AlignReply::unsafe_arena_set_allocated_imga_same(
    ::KP2D::Image* imga_same) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(imga_same_);
  }
  imga_same_ = imga_same;
  if (imga_same) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KP2D.AlignReply.imgA_same)
}
inline ::KP2D::Image* AlignReply::release_imga_same() {
  
  ::KP2D::Image* temp = imga_same_;
  imga_same_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::KP2D::Image* AlignReply::unsafe_arena_release_imga_same() {
  // @@protoc_insertion_point(field_release:KP2D.AlignReply.imgA_same)
  
  ::KP2D::Image* temp = imga_same_;
  imga_same_ = nullptr;
  return temp;
}
inline ::KP2D::Image* AlignReply::_internal_mutable_imga_same() {
  
  if (imga_same_ == nullptr) {
    auto* p = CreateMaybeMessage<::KP2D::Image>(GetArena());
    imga_same_ = p;
  }
  return imga_same_;
}
inline ::KP2D::Image* AlignReply::mutable_imga_same() {
  // @@protoc_insertion_point(field_mutable:KP2D.AlignReply.imgA_same)
  return _internal_mutable_imga_same();
}
inline void AlignReply::set_allocated_imga_same(::KP2D::Image* imga_same) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete imga_same_;
  }
  if (imga_same) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(imga_same);
    if (message_arena != submessage_arena) {
      imga_same = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, imga_same, submessage_arena);
    }
    
  } else {
    
  }
  imga_same_ = imga_same;
  // @@protoc_insertion_point(field_set_allocated:KP2D.AlignReply.imgA_same)
}

// .KP2D.Image imgB_same = 2;
inline bool AlignReply::_internal_has_imgb_same() const {
  return this != internal_default_instance() && imgb_same_ != nullptr;
}
inline bool AlignReply::has_imgb_same() const {
  return _internal_has_imgb_same();
}
inline void AlignReply::clear_imgb_same() {
  if (GetArena() == nullptr && imgb_same_ != nullptr) {
    delete imgb_same_;
  }
  imgb_same_ = nullptr;
}
inline const ::KP2D::Image& AlignReply::_internal_imgb_same() const {
  const ::KP2D::Image* p = imgb_same_;
  return p != nullptr ? *p : reinterpret_cast<const ::KP2D::Image&>(
      ::KP2D::_Image_default_instance_);
}
inline const ::KP2D::Image& AlignReply::imgb_same() const {
  // @@protoc_insertion_point(field_get:KP2D.AlignReply.imgB_same)
  return _internal_imgb_same();
}
inline void AlignReply::unsafe_arena_set_allocated_imgb_same(
    ::KP2D::Image* imgb_same) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(imgb_same_);
  }
  imgb_same_ = imgb_same;
  if (imgb_same) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KP2D.AlignReply.imgB_same)
}
inline ::KP2D::Image* AlignReply::release_imgb_same() {
  
  ::KP2D::Image* temp = imgb_same_;
  imgb_same_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::KP2D::Image* AlignReply::unsafe_arena_release_imgb_same() {
  // @@protoc_insertion_point(field_release:KP2D.AlignReply.imgB_same)
  
  ::KP2D::Image* temp = imgb_same_;
  imgb_same_ = nullptr;
  return temp;
}
inline ::KP2D::Image* AlignReply::_internal_mutable_imgb_same() {
  
  if (imgb_same_ == nullptr) {
    auto* p = CreateMaybeMessage<::KP2D::Image>(GetArena());
    imgb_same_ = p;
  }
  return imgb_same_;
}
inline ::KP2D::Image* AlignReply::mutable_imgb_same() {
  // @@protoc_insertion_point(field_mutable:KP2D.AlignReply.imgB_same)
  return _internal_mutable_imgb_same();
}
inline void AlignReply::set_allocated_imgb_same(::KP2D::Image* imgb_same) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete imgb_same_;
  }
  if (imgb_same) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(imgb_same);
    if (message_arena != submessage_arena) {
      imgb_same = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, imgb_same, submessage_arena);
    }
    
  } else {
    
  }
  imgb_same_ = imgb_same;
  // @@protoc_insertion_point(field_set_allocated:KP2D.AlignReply.imgB_same)
}

// repeated int32 imgA_roi = 3;
inline int AlignReply::_internal_imga_roi_size() const {
  return imga_roi_.size();
}
inline int AlignReply::imga_roi_size() const {
  return _internal_imga_roi_size();
}
inline void AlignReply::clear_imga_roi() {
  imga_roi_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AlignReply::_internal_imga_roi(int index) const {
  return imga_roi_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AlignReply::imga_roi(int index) const {
  // @@protoc_insertion_point(field_get:KP2D.AlignReply.imgA_roi)
  return _internal_imga_roi(index);
}
inline void AlignReply::set_imga_roi(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  imga_roi_.Set(index, value);
  // @@protoc_insertion_point(field_set:KP2D.AlignReply.imgA_roi)
}
inline void AlignReply::_internal_add_imga_roi(::PROTOBUF_NAMESPACE_ID::int32 value) {
  imga_roi_.Add(value);
}
inline void AlignReply::add_imga_roi(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_imga_roi(value);
  // @@protoc_insertion_point(field_add:KP2D.AlignReply.imgA_roi)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
AlignReply::_internal_imga_roi() const {
  return imga_roi_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
AlignReply::imga_roi() const {
  // @@protoc_insertion_point(field_list:KP2D.AlignReply.imgA_roi)
  return _internal_imga_roi();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
AlignReply::_internal_mutable_imga_roi() {
  return &imga_roi_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
AlignReply::mutable_imga_roi() {
  // @@protoc_insertion_point(field_mutable_list:KP2D.AlignReply.imgA_roi)
  return _internal_mutable_imga_roi();
}

// repeated int32 imgB_roi = 4;
inline int AlignReply::_internal_imgb_roi_size() const {
  return imgb_roi_.size();
}
inline int AlignReply::imgb_roi_size() const {
  return _internal_imgb_roi_size();
}
inline void AlignReply::clear_imgb_roi() {
  imgb_roi_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AlignReply::_internal_imgb_roi(int index) const {
  return imgb_roi_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AlignReply::imgb_roi(int index) const {
  // @@protoc_insertion_point(field_get:KP2D.AlignReply.imgB_roi)
  return _internal_imgb_roi(index);
}
inline void AlignReply::set_imgb_roi(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  imgb_roi_.Set(index, value);
  // @@protoc_insertion_point(field_set:KP2D.AlignReply.imgB_roi)
}
inline void AlignReply::_internal_add_imgb_roi(::PROTOBUF_NAMESPACE_ID::int32 value) {
  imgb_roi_.Add(value);
}
inline void AlignReply::add_imgb_roi(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_imgb_roi(value);
  // @@protoc_insertion_point(field_add:KP2D.AlignReply.imgB_roi)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
AlignReply::_internal_imgb_roi() const {
  return imgb_roi_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
AlignReply::imgb_roi() const {
  // @@protoc_insertion_point(field_list:KP2D.AlignReply.imgB_roi)
  return _internal_imgb_roi();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
AlignReply::_internal_mutable_imgb_roi() {
  return &imgb_roi_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
AlignReply::mutable_imgb_roi() {
  // @@protoc_insertion_point(field_mutable_list:KP2D.AlignReply.imgB_roi)
  return _internal_mutable_imgb_roi();
}

// int32 status = 5;
inline void AlignReply::clear_status() {
  status_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AlignReply::_internal_status() const {
  return status_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AlignReply::status() const {
  // @@protoc_insertion_point(field_get:KP2D.AlignReply.status)
  return _internal_status();
}
inline void AlignReply::_internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  status_ = value;
}
inline void AlignReply::set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:KP2D.AlignReply.status)
}

// -------------------------------------------------------------------

// GetEssentialMatrixReply

// .KP2D.Tensor matrix = 1;
inline bool GetEssentialMatrixReply::_internal_has_matrix() const {
  return this != internal_default_instance() && matrix_ != nullptr;
}
inline bool GetEssentialMatrixReply::has_matrix() const {
  return _internal_has_matrix();
}
inline void GetEssentialMatrixReply::clear_matrix() {
  if (GetArena() == nullptr && matrix_ != nullptr) {
    delete matrix_;
  }
  matrix_ = nullptr;
}
inline const ::KP2D::Tensor& GetEssentialMatrixReply::_internal_matrix() const {
  const ::KP2D::Tensor* p = matrix_;
  return p != nullptr ? *p : reinterpret_cast<const ::KP2D::Tensor&>(
      ::KP2D::_Tensor_default_instance_);
}
inline const ::KP2D::Tensor& GetEssentialMatrixReply::matrix() const {
  // @@protoc_insertion_point(field_get:KP2D.GetEssentialMatrixReply.matrix)
  return _internal_matrix();
}
inline void GetEssentialMatrixReply::unsafe_arena_set_allocated_matrix(
    ::KP2D::Tensor* matrix) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(matrix_);
  }
  matrix_ = matrix;
  if (matrix) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KP2D.GetEssentialMatrixReply.matrix)
}
inline ::KP2D::Tensor* GetEssentialMatrixReply::release_matrix() {
  
  ::KP2D::Tensor* temp = matrix_;
  matrix_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::KP2D::Tensor* GetEssentialMatrixReply::unsafe_arena_release_matrix() {
  // @@protoc_insertion_point(field_release:KP2D.GetEssentialMatrixReply.matrix)
  
  ::KP2D::Tensor* temp = matrix_;
  matrix_ = nullptr;
  return temp;
}
inline ::KP2D::Tensor* GetEssentialMatrixReply::_internal_mutable_matrix() {
  
  if (matrix_ == nullptr) {
    auto* p = CreateMaybeMessage<::KP2D::Tensor>(GetArena());
    matrix_ = p;
  }
  return matrix_;
}
inline ::KP2D::Tensor* GetEssentialMatrixReply::mutable_matrix() {
  // @@protoc_insertion_point(field_mutable:KP2D.GetEssentialMatrixReply.matrix)
  return _internal_mutable_matrix();
}
inline void GetEssentialMatrixReply::set_allocated_matrix(::KP2D::Tensor* matrix) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete matrix_;
  }
  if (matrix) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(matrix);
    if (message_arena != submessage_arena) {
      matrix = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, matrix, submessage_arena);
    }
    
  } else {
    
  }
  matrix_ = matrix;
  // @@protoc_insertion_point(field_set_allocated:KP2D.GetEssentialMatrixReply.matrix)
}

// int32 status = 2;
inline void GetEssentialMatrixReply::clear_status() {
  status_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GetEssentialMatrixReply::_internal_status() const {
  return status_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GetEssentialMatrixReply::status() const {
  // @@protoc_insertion_point(field_get:KP2D.GetEssentialMatrixReply.status)
  return _internal_status();
}
inline void GetEssentialMatrixReply::_internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  status_ = value;
}
inline void GetEssentialMatrixReply::set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:KP2D.GetEssentialMatrixReply.status)
}

// -------------------------------------------------------------------

// GetKPPosDescScoreReply

// .KP2D.Tensor kp = 1;
inline bool GetKPPosDescScoreReply::_internal_has_kp() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || kp_ != nullptr);
  return value;
}
inline bool GetKPPosDescScoreReply::has_kp() const {
  return _internal_has_kp();
}
inline void GetKPPosDescScoreReply::clear_kp() {
  if (GetArena() == nullptr && kp_ != nullptr) {
    delete kp_;
  }
  kp_ = nullptr;
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::KP2D::Tensor& GetKPPosDescScoreReply::_internal_kp() const {
  const ::KP2D::Tensor* p = kp_;
  return p != nullptr ? *p : reinterpret_cast<const ::KP2D::Tensor&>(
      ::KP2D::_Tensor_default_instance_);
}
inline const ::KP2D::Tensor& GetKPPosDescScoreReply::kp() const {
  // @@protoc_insertion_point(field_get:KP2D.GetKPPosDescScoreReply.kp)
  return _internal_kp();
}
inline void GetKPPosDescScoreReply::unsafe_arena_set_allocated_kp(
    ::KP2D::Tensor* kp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(kp_);
  }
  kp_ = kp;
  if (kp) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KP2D.GetKPPosDescScoreReply.kp)
}
inline ::KP2D::Tensor* GetKPPosDescScoreReply::release_kp() {
  _has_bits_[0] &= ~0x00000001u;
  ::KP2D::Tensor* temp = kp_;
  kp_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::KP2D::Tensor* GetKPPosDescScoreReply::unsafe_arena_release_kp() {
  // @@protoc_insertion_point(field_release:KP2D.GetKPPosDescScoreReply.kp)
  _has_bits_[0] &= ~0x00000001u;
  ::KP2D::Tensor* temp = kp_;
  kp_ = nullptr;
  return temp;
}
inline ::KP2D::Tensor* GetKPPosDescScoreReply::_internal_mutable_kp() {
  _has_bits_[0] |= 0x00000001u;
  if (kp_ == nullptr) {
    auto* p = CreateMaybeMessage<::KP2D::Tensor>(GetArena());
    kp_ = p;
  }
  return kp_;
}
inline ::KP2D::Tensor* GetKPPosDescScoreReply::mutable_kp() {
  // @@protoc_insertion_point(field_mutable:KP2D.GetKPPosDescScoreReply.kp)
  return _internal_mutable_kp();
}
inline void GetKPPosDescScoreReply::set_allocated_kp(::KP2D::Tensor* kp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete kp_;
  }
  if (kp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(kp);
    if (message_arena != submessage_arena) {
      kp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kp, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  kp_ = kp;
  // @@protoc_insertion_point(field_set_allocated:KP2D.GetKPPosDescScoreReply.kp)
}

// .KP2D.Tensor desc = 2;
inline bool GetKPPosDescScoreReply::_internal_has_desc() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || desc_ != nullptr);
  return value;
}
inline bool GetKPPosDescScoreReply::has_desc() const {
  return _internal_has_desc();
}
inline void GetKPPosDescScoreReply::clear_desc() {
  if (GetArena() == nullptr && desc_ != nullptr) {
    delete desc_;
  }
  desc_ = nullptr;
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::KP2D::Tensor& GetKPPosDescScoreReply::_internal_desc() const {
  const ::KP2D::Tensor* p = desc_;
  return p != nullptr ? *p : reinterpret_cast<const ::KP2D::Tensor&>(
      ::KP2D::_Tensor_default_instance_);
}
inline const ::KP2D::Tensor& GetKPPosDescScoreReply::desc() const {
  // @@protoc_insertion_point(field_get:KP2D.GetKPPosDescScoreReply.desc)
  return _internal_desc();
}
inline void GetKPPosDescScoreReply::unsafe_arena_set_allocated_desc(
    ::KP2D::Tensor* desc) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(desc_);
  }
  desc_ = desc;
  if (desc) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KP2D.GetKPPosDescScoreReply.desc)
}
inline ::KP2D::Tensor* GetKPPosDescScoreReply::release_desc() {
  _has_bits_[0] &= ~0x00000002u;
  ::KP2D::Tensor* temp = desc_;
  desc_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::KP2D::Tensor* GetKPPosDescScoreReply::unsafe_arena_release_desc() {
  // @@protoc_insertion_point(field_release:KP2D.GetKPPosDescScoreReply.desc)
  _has_bits_[0] &= ~0x00000002u;
  ::KP2D::Tensor* temp = desc_;
  desc_ = nullptr;
  return temp;
}
inline ::KP2D::Tensor* GetKPPosDescScoreReply::_internal_mutable_desc() {
  _has_bits_[0] |= 0x00000002u;
  if (desc_ == nullptr) {
    auto* p = CreateMaybeMessage<::KP2D::Tensor>(GetArena());
    desc_ = p;
  }
  return desc_;
}
inline ::KP2D::Tensor* GetKPPosDescScoreReply::mutable_desc() {
  // @@protoc_insertion_point(field_mutable:KP2D.GetKPPosDescScoreReply.desc)
  return _internal_mutable_desc();
}
inline void GetKPPosDescScoreReply::set_allocated_desc(::KP2D::Tensor* desc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete desc_;
  }
  if (desc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(desc);
    if (message_arena != submessage_arena) {
      desc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, desc, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  desc_ = desc;
  // @@protoc_insertion_point(field_set_allocated:KP2D.GetKPPosDescScoreReply.desc)
}

// int32 status = 3;
inline void GetKPPosDescScoreReply::clear_status() {
  status_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GetKPPosDescScoreReply::_internal_status() const {
  return status_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GetKPPosDescScoreReply::status() const {
  // @@protoc_insertion_point(field_get:KP2D.GetKPPosDescScoreReply.status)
  return _internal_status();
}
inline void GetKPPosDescScoreReply::_internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  status_ = value;
}
inline void GetKPPosDescScoreReply::set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:KP2D.GetKPPosDescScoreReply.status)
}

// -------------------------------------------------------------------

// GetKPPosDescScoreMapReply

// .KP2D.Tensor prob = 1;
inline bool GetKPPosDescScoreMapReply::_internal_has_prob() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || prob_ != nullptr);
  return value;
}
inline bool GetKPPosDescScoreMapReply::has_prob() const {
  return _internal_has_prob();
}
inline void GetKPPosDescScoreMapReply::clear_prob() {
  if (GetArena() == nullptr && prob_ != nullptr) {
    delete prob_;
  }
  prob_ = nullptr;
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::KP2D::Tensor& GetKPPosDescScoreMapReply::_internal_prob() const {
  const ::KP2D::Tensor* p = prob_;
  return p != nullptr ? *p : reinterpret_cast<const ::KP2D::Tensor&>(
      ::KP2D::_Tensor_default_instance_);
}
inline const ::KP2D::Tensor& GetKPPosDescScoreMapReply::prob() const {
  // @@protoc_insertion_point(field_get:KP2D.GetKPPosDescScoreMapReply.prob)
  return _internal_prob();
}
inline void GetKPPosDescScoreMapReply::unsafe_arena_set_allocated_prob(
    ::KP2D::Tensor* prob) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(prob_);
  }
  prob_ = prob;
  if (prob) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KP2D.GetKPPosDescScoreMapReply.prob)
}
inline ::KP2D::Tensor* GetKPPosDescScoreMapReply::release_prob() {
  _has_bits_[0] &= ~0x00000001u;
  ::KP2D::Tensor* temp = prob_;
  prob_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::KP2D::Tensor* GetKPPosDescScoreMapReply::unsafe_arena_release_prob() {
  // @@protoc_insertion_point(field_release:KP2D.GetKPPosDescScoreMapReply.prob)
  _has_bits_[0] &= ~0x00000001u;
  ::KP2D::Tensor* temp = prob_;
  prob_ = nullptr;
  return temp;
}
inline ::KP2D::Tensor* GetKPPosDescScoreMapReply::_internal_mutable_prob() {
  _has_bits_[0] |= 0x00000001u;
  if (prob_ == nullptr) {
    auto* p = CreateMaybeMessage<::KP2D::Tensor>(GetArena());
    prob_ = p;
  }
  return prob_;
}
inline ::KP2D::Tensor* GetKPPosDescScoreMapReply::mutable_prob() {
  // @@protoc_insertion_point(field_mutable:KP2D.GetKPPosDescScoreMapReply.prob)
  return _internal_mutable_prob();
}
inline void GetKPPosDescScoreMapReply::set_allocated_prob(::KP2D::Tensor* prob) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete prob_;
  }
  if (prob) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(prob);
    if (message_arena != submessage_arena) {
      prob = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, prob, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  prob_ = prob;
  // @@protoc_insertion_point(field_set_allocated:KP2D.GetKPPosDescScoreMapReply.prob)
}

// .KP2D.Tensor desc = 2;
inline bool GetKPPosDescScoreMapReply::_internal_has_desc() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || desc_ != nullptr);
  return value;
}
inline bool GetKPPosDescScoreMapReply::has_desc() const {
  return _internal_has_desc();
}
inline void GetKPPosDescScoreMapReply::clear_desc() {
  if (GetArena() == nullptr && desc_ != nullptr) {
    delete desc_;
  }
  desc_ = nullptr;
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::KP2D::Tensor& GetKPPosDescScoreMapReply::_internal_desc() const {
  const ::KP2D::Tensor* p = desc_;
  return p != nullptr ? *p : reinterpret_cast<const ::KP2D::Tensor&>(
      ::KP2D::_Tensor_default_instance_);
}
inline const ::KP2D::Tensor& GetKPPosDescScoreMapReply::desc() const {
  // @@protoc_insertion_point(field_get:KP2D.GetKPPosDescScoreMapReply.desc)
  return _internal_desc();
}
inline void GetKPPosDescScoreMapReply::unsafe_arena_set_allocated_desc(
    ::KP2D::Tensor* desc) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(desc_);
  }
  desc_ = desc;
  if (desc) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KP2D.GetKPPosDescScoreMapReply.desc)
}
inline ::KP2D::Tensor* GetKPPosDescScoreMapReply::release_desc() {
  _has_bits_[0] &= ~0x00000002u;
  ::KP2D::Tensor* temp = desc_;
  desc_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::KP2D::Tensor* GetKPPosDescScoreMapReply::unsafe_arena_release_desc() {
  // @@protoc_insertion_point(field_release:KP2D.GetKPPosDescScoreMapReply.desc)
  _has_bits_[0] &= ~0x00000002u;
  ::KP2D::Tensor* temp = desc_;
  desc_ = nullptr;
  return temp;
}
inline ::KP2D::Tensor* GetKPPosDescScoreMapReply::_internal_mutable_desc() {
  _has_bits_[0] |= 0x00000002u;
  if (desc_ == nullptr) {
    auto* p = CreateMaybeMessage<::KP2D::Tensor>(GetArena());
    desc_ = p;
  }
  return desc_;
}
inline ::KP2D::Tensor* GetKPPosDescScoreMapReply::mutable_desc() {
  // @@protoc_insertion_point(field_mutable:KP2D.GetKPPosDescScoreMapReply.desc)
  return _internal_mutable_desc();
}
inline void GetKPPosDescScoreMapReply::set_allocated_desc(::KP2D::Tensor* desc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete desc_;
  }
  if (desc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(desc);
    if (message_arena != submessage_arena) {
      desc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, desc, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  desc_ = desc;
  // @@protoc_insertion_point(field_set_allocated:KP2D.GetKPPosDescScoreMapReply.desc)
}

// int32 status = 3;
inline void GetKPPosDescScoreMapReply::clear_status() {
  status_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GetKPPosDescScoreMapReply::_internal_status() const {
  return status_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GetKPPosDescScoreMapReply::status() const {
  // @@protoc_insertion_point(field_get:KP2D.GetKPPosDescScoreMapReply.status)
  return _internal_status();
}
inline void GetKPPosDescScoreMapReply::_internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  status_ = value;
}
inline void GetKPPosDescScoreMapReply::set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:KP2D.GetKPPosDescScoreMapReply.status)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace KP2D

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_kp2d_2eproto
